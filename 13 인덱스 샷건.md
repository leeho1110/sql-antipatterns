# 13. 인덱스 샷건

- 데이터베이스의 성능을 향상시키는 가장 좋은 방법은 인덱스를 잘 활용하는 것입니다.
    - 필요하지만 정의되지 않은 것과 불필요한 정의가 많이 이루어져 있는 것, 모두 문제입니다.
- 우리는 데이터베이스에서 수정이나 삭제, 새로운 값의 추가보다 조회를 월등히 더 많이 수행합니다.
    - 이는 인덱스의 상태 유지로 인해 발생하는 C,U,D에서의 오버헤드는 R에서의 이점과 비교해보면 그리 크지 않다는 것이죠.
- 하지만 인덱스를 사용하는 쿼리를 실행해야만 인덱스를 ‘사용’한다고 볼 수 있습니다.
    - 쿼리가 실행될 때 활용되지 않는 인덱스는 사실상 아무런 이득이 없이 저장공간만 낭비하고 불필요한 오버헤드만 발생시킬 뿐이죠.
    - 대표적으로 PK의 중복 인덱스가 있습니다. PK는 (대부분 벤더에서) 데이터베이스 내부에서 자동으로 인덱스를 생성합니다.
- 반대로 인덱스를 사용할 수 없는 쿼리를 작성하는 것도 문제입니다.
- 그렇다면 인덱스를 어떻게 잘 작성할 수 있을까요? 여기서 제시하는 방법론은 MENTOR 입니다. Measure, Explain, Norminate, Test, Optiomize, Rebuild죠.
    1. 먼저 **Measure, 측정**입니다.
        - 대부분의 데이터베이스에서는 SQL 쿼리별 실행 시간을 로그로 남깁니다.
        - 주로 사용하는 MySQL에서는 `slow query log` 라고 부르는 실행이 느린 쿼리에 대한 로그를 남깁니다. 기본값으로 10초가 넘어가는 쿼리들을 채집하며, `long_query_time` 설정 파라미터에 임계치를 지정할 수 있습니다.
        - 측정 시 쿼리 결과를 캐싱하는 기능도 비활성화시켜야 합니다.
    2. 측정을 완료했다면 두번째는 **Explain, 확인**입니다.
        - 모든 데이터베이스는 옵티마이저를 통해 쿼리가 사용하는 인덱스를 확인할 수 있습니다. 일반적으로  **Execution Plan, 실행계획**이라고 하죠.
        - MySQL에서는 EXPLAIN 키워드를 통해 알 수 있으며, 리포트를 해석하는 메뉴얼은 MySQL을 기준으로 Optiomizing Queries with EXPLAIN을 통해 알 수 있습니다.
        - 이 과정에서 어떤 인덱스가 사용되고 있는지, 어느 부분에서 추가로 인덱스를 사용하게 만들어서 성능을 향상시킬지 가늠할 수 있습니다.
    3. **Nominate, 지명**
        - 이 부분에서 위에서 이야기했던 인덱스를 사용하지 않고 테이블에 접근하는 부분을 살펴볼 수 있습니다.
            - MySQL에서는 MySQL Enterprise Query Analyzer가 존재합니다.
        - 만약 우리가 조회하고자 하는 데이터를 인덱스가 생성된 컬럼으로 해결할 수 있다면 이 땐 **커버링 인덱스가 동작**합니다.
            - 커버링 인덱스가 동작하지 않는 경우라면, 인덱스를 통해 데이터가 존재하는 위치를 얻고 해당 데이터를 조회하기 위해 페이지 블록으로 이동해야 합니다.
    4. **Test, 테스트**
        - 앞선 단계에서 인덱스를 적절하게 생성했다면 실제로 쿼리가 인덱스를 타는지 확인해야 합니다.
    5. **Optimize, 최적화**
        - 인덱스는 자주 사용되는 데이터 구조 중 하나입니다. 그 의미는 캐시 메모리에 적재되었을 때 그 효율이 극대화된다는 것이죠.
        - 캐시 메모리를 전체 메모리에서 얼마나 설정할지는 상황마다 다릅니다.
        - MySQL에서는 `LOAD INDEX INTO CACHE` 문을 사용해 캐시 메모리에 인덱스를 올려놓을 수 있습니다.
    6. **Rebuild, 재구성**
        - 모든 것이 그렇듯 인덱스 역시 생성한 이후 많은 수정 과정을 거치게 되면 균형을 잃습니다.
            - 여기서 균형은 인덱스가 생성될 때 사용되는 내부 자료구조인 트리로 인해 발생합니다.
        - 리빌딩을 언제 해줄지 역시 다릅니다.